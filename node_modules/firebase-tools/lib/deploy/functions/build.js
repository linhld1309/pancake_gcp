"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveBackend = exports.of = exports.empty = void 0;
const backend = require("./backend");
const proto = require("../../gcp/proto");
const api = require("../../.../../api");
const error_1 = require("../../error");
const functional_1 = require("../../functional");
function empty() {
    return {
        requiredAPIs: [],
        endpoints: {},
        params: [],
    };
}
exports.empty = empty;
function of(endpoints) {
    const build = empty();
    build.endpoints = endpoints;
    return build;
}
exports.of = of;
function resolveInt(from) {
    if (from == null) {
        return 0;
    }
    else if (typeof from === "string") {
        throw new error_1.FirebaseError("CEL evaluation of expression '" + from + "' not yet supported");
    }
    return from;
}
function resolveString(from) {
    if (from == null) {
        return "";
    }
    else if (from.includes("{{") && from.includes("}}")) {
        throw new error_1.FirebaseError("CEL evaluation of expression '" + from + "' not yet supported");
    }
    return from;
}
function resolveBoolean(from) {
    if (from == null) {
        return false;
    }
    else if (typeof from === "string") {
        throw new error_1.FirebaseError("CEL evaluation of expression '" + from + "' not yet supported");
    }
    return from;
}
function isMemoryOption(value) {
    return value == null || [128, 256, 512, 1024, 2048, 4096, 8192].includes(value);
}
function resolveBackend(build, userEnvs) {
    for (const param of build.params) {
        const expectedEnv = param.param;
        if (!userEnvs.hasOwnProperty(expectedEnv)) {
            throw new error_1.FirebaseError("Build specified parameter " +
                expectedEnv +
                " but it was not present in the user dotenv files or Cloud Secret Manager");
        }
    }
    const bkEndpoints = [];
    for (const endpointId of Object.keys(build.endpoints)) {
        const bdEndpoint = build.endpoints[endpointId];
        let regions = bdEndpoint.region;
        if (typeof regions === "undefined") {
            regions = [api.functionsDefaultRegion];
        }
        for (const region of regions) {
            const trigger = discoverTrigger(bdEndpoint);
            if (typeof bdEndpoint.platform === "undefined") {
                throw new error_1.FirebaseError("platform can't be undefined");
            }
            if (!isMemoryOption(bdEndpoint.availableMemoryMb)) {
                throw new error_1.FirebaseError("available memory must be a supported value, if present");
            }
            let timeout;
            if (bdEndpoint.timeoutSeconds) {
                timeout = resolveInt(bdEndpoint.timeoutSeconds);
            }
            else {
                timeout = 60;
            }
            const bkEndpoint = Object.assign({ id: endpointId, project: bdEndpoint.project, region: region, entryPoint: bdEndpoint.entryPoint, platform: bdEndpoint.platform, runtime: bdEndpoint.runtime, timeoutSeconds: timeout }, trigger);
            proto.renameIfPresent(bkEndpoint, bdEndpoint, "maxInstances", "maxInstances", resolveInt);
            proto.renameIfPresent(bkEndpoint, bdEndpoint, "minInstances", "minInstances", resolveInt);
            proto.renameIfPresent(bkEndpoint, bdEndpoint, "concurrency", "concurrency", resolveInt);
            proto.copyIfPresent(bkEndpoint, bdEndpoint, "ingressSettings", "availableMemoryMb", "environmentVariables", "labels");
            proto.copyIfPresent(bkEndpoint, bdEndpoint, "secretEnvironmentVariables");
            if (bdEndpoint.vpc) {
                bkEndpoint.vpc = {
                    connector: resolveString(bdEndpoint.vpc.connector).replace("$REGION", region),
                };
                proto.copyIfPresent(bkEndpoint.vpc, bdEndpoint.vpc, "egressSettings");
            }
            if (bdEndpoint.serviceAccount) {
                bkEndpoint.serviceAccountEmail = bdEndpoint.serviceAccount;
            }
            bkEndpoints.push(bkEndpoint);
        }
    }
    const bkend = backend.of(...bkEndpoints);
    bkend.requiredAPIs = build.requiredAPIs;
    return bkend;
}
exports.resolveBackend = resolveBackend;
function discoverTrigger(endpoint) {
    let trigger;
    if ("httpsTrigger" in endpoint) {
        const bkHttps = {};
        if (endpoint.httpsTrigger.invoker) {
            bkHttps.invoker = [endpoint.httpsTrigger.invoker];
        }
        trigger = { httpsTrigger: bkHttps };
    }
    else if ("callableTrigger" in endpoint) {
        trigger = { callableTrigger: {} };
    }
    else if ("blockingTrigger" in endpoint) {
        trigger = { blockingTrigger: endpoint.blockingTrigger };
    }
    else if ("eventTrigger" in endpoint) {
        const bkEventFilters = {};
        for (const key in endpoint.eventTrigger.eventFilters) {
            if (typeof key === "string") {
                bkEventFilters[key] = resolveString(endpoint.eventTrigger.eventFilters[key]);
            }
        }
        const bkEvent = {
            eventType: endpoint.eventTrigger.eventType,
            eventFilters: bkEventFilters,
            retry: resolveBoolean(endpoint.eventTrigger.retry),
        };
        if (endpoint.eventTrigger.serviceAccount) {
            bkEvent.serviceAccountEmail = endpoint.eventTrigger.serviceAccount;
        }
        if (endpoint.eventTrigger.region) {
            bkEvent.region = resolveString(endpoint.eventTrigger.region);
        }
        trigger = { eventTrigger: bkEvent };
    }
    else if ("scheduleTrigger" in endpoint) {
        const bkSchedule = {
            schedule: resolveString(endpoint.scheduleTrigger.schedule),
            timeZone: resolveString(endpoint.scheduleTrigger.timeZone),
        };
        const bkRetry = {};
        if (endpoint.scheduleTrigger.retryConfig.maxBackoffSeconds) {
            bkRetry.maxBackoffDuration = proto.durationFromSeconds(resolveInt(endpoint.scheduleTrigger.retryConfig.maxBackoffSeconds));
        }
        if (endpoint.scheduleTrigger.retryConfig.minBackoffSeconds) {
            bkRetry.minBackoffDuration = proto.durationFromSeconds(resolveInt(endpoint.scheduleTrigger.retryConfig.minBackoffSeconds));
        }
        if (endpoint.scheduleTrigger.retryConfig.maxRetrySeconds) {
            bkRetry.maxRetryDuration = proto.durationFromSeconds(resolveInt(endpoint.scheduleTrigger.retryConfig.maxRetrySeconds));
        }
        proto.copyIfPresent(bkRetry, endpoint.scheduleTrigger.retryConfig, "retryCount", "maxDoublings");
        bkSchedule.retryConfig = bkRetry;
        trigger = { scheduleTrigger: bkSchedule };
    }
    else if ("taskQueueTrigger" in endpoint) {
        const bkTaskQueue = {};
        if (endpoint.taskQueueTrigger.rateLimits) {
            const bkRateLimits = {};
            proto.renameIfPresent(bkRateLimits, endpoint.taskQueueTrigger.rateLimits, "maxConcurrentDispatches", "maxConcurrentDispatches", resolveInt);
            proto.renameIfPresent(bkRateLimits, endpoint.taskQueueTrigger.rateLimits, "maxDispatchesPerSecond", "maxDispatchesPerSecond", resolveInt);
            bkTaskQueue.rateLimits = bkRateLimits;
        }
        if (endpoint.taskQueueTrigger.retryConfig) {
            const bkRetryConfig = {};
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxAttempts", "maxAttempts", resolveInt);
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxBackoffSeconds", "maxBackoffSeconds", (from) => {
                return proto.durationFromSeconds(resolveInt(from));
            });
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "minBackoffSeconds", "minBackoffSeconds", (from) => {
                return proto.durationFromSeconds(resolveInt(from));
            });
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxRetrySeconds", "maxRetryDurationSeconds", (from) => {
                return proto.durationFromSeconds(resolveInt(from));
            });
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxDoublings", "maxDoublings", resolveInt);
            bkTaskQueue.retryConfig = bkRetryConfig;
        }
        if (endpoint.taskQueueTrigger.invoker) {
            bkTaskQueue.invoker = endpoint.taskQueueTrigger.invoker.map((sa) => resolveString(sa));
        }
        trigger = { taskQueueTrigger: bkTaskQueue };
    }
    else {
        (0, functional_1.assertExhaustive)(endpoint);
    }
    return trigger;
}
