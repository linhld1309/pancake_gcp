"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.functionsConfigClone = void 0;
const _ = require("lodash");
const clc = require("cli-color");
const error_1 = require("./error");
const functionsConfig = require("./functionsConfig");
const runtimeconfig = require("./gcp/runtimeconfig");
function matchPrefix(short, long) {
    if (short.length > long.length) {
        return false;
    }
    return _.reduce(short, (accum, x, i) => {
        return accum && x === long[i];
    }, true);
}
function applyExcept(json, except) {
    _.forEach(except, (key) => {
        _.unset(json, key);
    });
}
function cloneVariable(varName, toProject) {
    return runtimeconfig.variables.get(varName).then((variable) => {
        const id = functionsConfig.varNameToIds(variable.name);
        return runtimeconfig.variables.set(toProject, id.config, id.variable, variable.text);
    });
}
function cloneConfig(configName, toProject) {
    return runtimeconfig.variables.list(configName).then((variables) => {
        return Promise.all(_.map(variables, (variable) => {
            return cloneVariable(variable.name, toProject);
        }));
    });
}
async function cloneConfigOrVariable(key, fromProject, toProject) {
    const parts = key.split(".");
    if (_.includes(functionsConfig.RESERVED_NAMESPACES, parts[0])) {
        throw new error_1.FirebaseError("Cannot clone reserved namespace " + clc.bold(parts[0]));
    }
    const configName = _.join(["projects", fromProject, "configs", parts[0]], "/");
    if (parts.length === 1) {
        return cloneConfig(configName, toProject);
    }
    return runtimeconfig.variables.list(configName).then((variables) => {
        const promises = [];
        _.forEach(variables, (variable) => {
            const varId = functionsConfig.varNameToIds(variable.name).variable;
            const variablePrefixFilter = parts.slice(1);
            if (matchPrefix(variablePrefixFilter, varId.split("/"))) {
                promises.push(cloneVariable(variable.name, toProject));
            }
        });
        return Promise.all(promises);
    });
}
async function functionsConfigClone(fromProject, toProject, only, except = []) {
    if (only) {
        return Promise.all(_.map(only, (key) => {
            return cloneConfigOrVariable(key, fromProject, toProject);
        }));
    }
    return functionsConfig.materializeAll(fromProject).then((toClone) => {
        _.unset(toClone, "firebase");
        applyExcept(toClone, except);
        return Promise.all(_.map(toClone, (val, configId) => {
            return functionsConfig.setVariablesRecursive(toProject, configId, "", val);
        }));
    });
}
exports.functionsConfigClone = functionsConfigClone;
